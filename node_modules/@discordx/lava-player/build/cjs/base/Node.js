"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseNode = void 0;
const tslib_1 = require("tslib");
/* eslint-disable @typescript-eslint/no-explicit-any */
const events_1 = require("events");
const ws_1 = tslib_1.__importDefault(require("ws"));
const Connection_js_1 = require("../core/Connection.js");
const Http_js_1 = require("../core/Http.js");
const PlayerStore_js_1 = tslib_1.__importDefault(require("../core/PlayerStore.js"));
class BaseNode extends events_1.EventEmitter {
    password;
    userId;
    shardCount;
    connection;
    players = new PlayerStore_js_1.default(this);
    http;
    voiceStates = new Map();
    voiceServers = new Map();
    _expectingConnection = new Set();
    constructor({ password, userId, shardCount, host }) {
        super();
        this.password = password;
        this.userId = userId;
        this.shardCount = shardCount;
        const restIsSecure = host?.rest?.secure ?? host?.secure ?? false;
        const restAddress = host?.rest?.address ?? host?.address ?? "localhost";
        const restPort = host?.rest?.port ?? host?.port ?? 2333;
        this.http = new Http_js_1.Http(this, `${restIsSecure ? "https" : "http"}://${restAddress}:${restPort}`);
        const wsIsSecure = host?.secure ?? false;
        const wsAddress = host?.address ?? "localhost";
        const wsPort = host?.port ?? 2333;
        this.connection = new Connection_js_1.Connection(this, `${wsIsSecure ? "wss" : "ws"}://${wsAddress}:${wsPort}`, host?.connectionOptions);
    }
    get connected() {
        return this.connection?.ws.readyState === ws_1.default.OPEN;
    }
    load(identifier) {
        if (this.http) {
            return this.http.load(identifier);
        }
        throw new Error("no available http module");
    }
    decode(tracks) {
        if (this.http) {
            return this.http.decode(tracks);
        }
        throw new Error("no available http module");
    }
    voiceStateUpdate(packet) {
        if (packet.user_id !== this.userId) {
            return Promise.resolve(false);
        }
        if (packet.channel_id) {
            this.voiceStates.set(packet.guild_id, packet);
            return this._tryConnection(packet.guild_id);
        }
        else {
            this.voiceServers.delete(packet.guild_id);
            this.voiceStates.delete(packet.guild_id);
        }
        return Promise.resolve(false);
    }
    voiceServerUpdate(packet) {
        this.voiceServers.set(packet.guild_id, packet);
        this._expectingConnection.add(packet.guild_id);
        return this._tryConnection(packet.guild_id);
    }
    connect() {
        this.connection?.connect();
    }
    disconnect(code, data) {
        if (this.connection) {
            return this.connection.close(code, data);
        }
        return Promise.resolve();
    }
    async destroy(code, data) {
        await Promise.all([...this.players.values()].map((player) => player.destroy()));
        await this.disconnect(code, data);
    }
    async _tryConnection(guildId) {
        const state = this.voiceStates.get(guildId);
        const server = this.voiceServers.get(guildId);
        if (!state || !server || !this._expectingConnection.has(guildId)) {
            return false;
        }
        await this.players.get(guildId).voiceUpdate(state.session_id, server);
        this._expectingConnection.delete(guildId);
        return true;
    }
}
exports.BaseNode = BaseNode;
//# sourceMappingURL=Node.js.map