"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Player = void 0;
/* eslint-disable @typescript-eslint/no-explicit-any */
/* eslint-disable camelcase */
const events_1 = require("events");
const index_js_1 = require("../types/index.js");
class Player extends events_1.EventEmitter {
    node;
    guildId;
    status = index_js_1.Status.INSTANTIATED;
    constructor(node, guildId) {
        super();
        this.node = node;
        this.guildId = guildId;
        this.on("event", (d) => {
            switch (d.type) {
                case index_js_1.EventType.TrackStartEvent:
                    this.status = index_js_1.Status.PLAYING;
                    break;
                case index_js_1.EventType.TrackEndEvent:
                    if (d.reason !== "REPLACED") {
                        this.status = index_js_1.Status.ENDED;
                    }
                    break;
                case index_js_1.EventType.TrackExceptionEvent:
                    this.status = index_js_1.Status.ERRORED;
                    break;
                case index_js_1.EventType.TrackStuckEvent:
                    this.status = index_js_1.Status.STUCK;
                    break;
                case index_js_1.EventType.WebSocketClosedEvent:
                    this.status = index_js_1.Status.ENDED;
                    break;
                default:
                    this.status = index_js_1.Status.UNKNOWN;
                    break;
            }
        });
    }
    get playing() {
        return this.status === index_js_1.Status.PLAYING;
    }
    get paused() {
        return this.status === index_js_1.Status.PAUSED;
    }
    get voiceState() {
        const state = this.node.voiceStates.get(this.guildId);
        if (!state) {
            return;
        }
        return state;
    }
    get voiceServer() {
        return this.node.voiceServers.get(this.guildId);
    }
    async moveTo(node) {
        if (this.node === node) {
            return;
        }
        if (!this.voiceServer || !this.voiceState) {
            throw new Error("no voice state/server data to move");
        }
        await this.destroy();
        await Promise.all([
            node.voiceStateUpdate(this.voiceState),
            node.voiceServerUpdate(this.voiceServer),
        ]);
    }
    leave() {
        return this.join(null);
    }
    join(channel, { deaf = false, mute = false } = {}) {
        this.node.voiceServers.delete(this.guildId);
        this.node.voiceStates.delete(this.guildId);
        return this.node.send(this.guildId, {
            d: {
                channel_id: channel,
                guild_id: this.guildId,
                self_deaf: deaf,
                self_mute: mute,
            },
            op: 4,
        });
    }
    async play(track, { start, end, noReplace, pause } = {}) {
        await this.send("play", {
            endTime: end,
            noReplace,
            pause,
            startTime: start,
            track: typeof track === "object" ? track.track : track,
        });
        this.status = index_js_1.Status.PLAYING;
    }
    setVolume(vol) {
        return this.send("volume", { volume: vol });
    }
    setEqualizer(bands) {
        return this.send("equalizer", { bands });
    }
    setFilters(options) {
        return this.send("filters", options);
    }
    seek(position) {
        return this.send("seek", { position });
    }
    async pause(paused = true) {
        await this.send("pause", { pause: paused });
        if (paused) {
            this.status = index_js_1.Status.PAUSED;
        }
        else {
            this.status = index_js_1.Status.PLAYING;
        }
    }
    async stop() {
        await this.send("stop");
        this.status = index_js_1.Status.ENDED;
    }
    async destroy() {
        if (this.node.connected) {
            await this.send("destroy");
        }
        this.status = index_js_1.Status.ENDED;
        this.node.players.delete(this.guildId);
    }
    voiceUpdate(sessionId, event) {
        return this.send("voiceUpdate", {
            event,
            sessionId,
        });
    }
    send(op, d = {}) {
        const conn = this.node.connection;
        if (conn) {
            return conn.send(Object.assign({
                guildId: this.guildId,
                op,
            }, d));
        }
        else {
            return Promise.reject(new Error("no WebSocket connection available"));
        }
    }
}
exports.Player = Player;
//# sourceMappingURL=Player.js.map