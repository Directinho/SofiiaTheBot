"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Http = exports.HTTPError = void 0;
const tslib_1 = require("tslib");
const http_1 = require("http");
const url_1 = require("url");
const RoutePlanner_js_1 = tslib_1.__importDefault(require("./RoutePlanner.js"));
class HTTPError extends Error {
    method;
    statusCode;
    headers;
    path;
    get statusMessage() {
        return http_1.STATUS_CODES[this.statusCode];
    }
    constructor(httpMessage, method, url) {
        super(`${httpMessage.statusCode} ${http_1.STATUS_CODES[httpMessage.statusCode]}`);
        this.statusCode = httpMessage.statusCode;
        this.headers = httpMessage.headers;
        this.name = this.constructor.name;
        this.path = url.toString();
        this.method = method;
    }
}
exports.HTTPError = HTTPError;
class Http {
    node;
    input;
    base;
    routePlanner = new RoutePlanner_js_1.default(this);
    constructor(node, input, base) {
        this.node = node;
        this.input = input;
        this.base = base;
    }
    url() {
        return new url_1.URL(this.input, this.base);
    }
    load(identifier) {
        const url = this.url();
        url.pathname = "/loadtracks";
        url.searchParams.append("identifier", identifier);
        return this.do("GET", url);
    }
    decode(tracks) {
        const url = this.url();
        if (Array.isArray(tracks)) {
            url.pathname = "/decodetracks";
            return this.do("POST", url, Buffer.from(JSON.stringify(tracks)));
        }
        else {
            url.pathname = "/decodetrack";
            url.searchParams.append("track", tracks);
            return this.do("GET", url);
        }
    }
    async do(method, url, data) {
        const message = await new Promise((resolve) => {
            const req = (0, http_1.request)({
                headers: {
                    Accept: "application/json",
                    Authorization: this.node.password,
                    "Content-Type": "application/json",
                },
                hostname: url.hostname,
                method,
                path: url.pathname + url.search,
                port: url.port,
                protocol: url.protocol,
            }, resolve);
            if (data) {
                req.write(data);
            }
            req.end();
        });
        if (message.statusCode &&
            message.statusCode >= 200 &&
            message.statusCode < 300) {
            const chunks = [];
            message.on("data", (chunk) => {
                if (typeof chunk === "string") {
                    chunk = Buffer.from(chunk);
                }
                chunks.push(chunk);
            });
            return new Promise((resolve, reject) => {
                message.once("error", reject);
                message.once("end", () => {
                    message.removeAllListeners();
                    try {
                        const dataX = Buffer.concat(chunks);
                        resolve(JSON.parse(dataX.toString()));
                    }
                    catch (e) {
                        reject(e);
                    }
                });
            });
        }
        throw new HTTPError(message, method, url);
    }
}
exports.Http = Http;
//# sourceMappingURL=Http.js.map