import { request, STATUS_CODES } from "http";
import { URL } from "url";
import RoutePlanner from "./RoutePlanner.js";
export class HTTPError extends Error {
    method;
    statusCode;
    headers;
    path;
    get statusMessage() {
        return STATUS_CODES[this.statusCode];
    }
    constructor(httpMessage, method, url) {
        super(`${httpMessage.statusCode} ${STATUS_CODES[httpMessage.statusCode]}`);
        this.statusCode = httpMessage.statusCode;
        this.headers = httpMessage.headers;
        this.name = this.constructor.name;
        this.path = url.toString();
        this.method = method;
    }
}
export class Http {
    node;
    input;
    base;
    routePlanner = new RoutePlanner(this);
    constructor(node, input, base) {
        this.node = node;
        this.input = input;
        this.base = base;
    }
    url() {
        return new URL(this.input, this.base);
    }
    load(identifier) {
        const url = this.url();
        url.pathname = "/loadtracks";
        url.searchParams.append("identifier", identifier);
        return this.do("GET", url);
    }
    decode(tracks) {
        const url = this.url();
        if (Array.isArray(tracks)) {
            url.pathname = "/decodetracks";
            return this.do("POST", url, Buffer.from(JSON.stringify(tracks)));
        }
        else {
            url.pathname = "/decodetrack";
            url.searchParams.append("track", tracks);
            return this.do("GET", url);
        }
    }
    async do(method, url, data) {
        const message = await new Promise((resolve) => {
            const req = request({
                headers: {
                    Accept: "application/json",
                    Authorization: this.node.password,
                    "Content-Type": "application/json",
                },
                hostname: url.hostname,
                method,
                path: url.pathname + url.search,
                port: url.port,
                protocol: url.protocol,
            }, resolve);
            if (data) {
                req.write(data);
            }
            req.end();
        });
        if (message.statusCode &&
            message.statusCode >= 200 &&
            message.statusCode < 300) {
            const chunks = [];
            message.on("data", (chunk) => {
                if (typeof chunk === "string") {
                    chunk = Buffer.from(chunk);
                }
                chunks.push(chunk);
            });
            return new Promise((resolve, reject) => {
                message.once("error", reject);
                message.once("end", () => {
                    message.removeAllListeners();
                    try {
                        const dataX = Buffer.concat(chunks);
                        resolve(JSON.parse(dataX.toString()));
                    }
                    catch (e) {
                        reject(e);
                    }
                });
            });
        }
        throw new HTTPError(message, method, url);
    }
}
//# sourceMappingURL=Http.js.map